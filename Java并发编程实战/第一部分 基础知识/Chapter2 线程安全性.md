# 第二章 线程安全性

* 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的 （Mutable）状态的访问
    > “共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。

* Java中的主要同步机制是关键字 sychronized，它提供了一种独占的加锁机方式，但“同步”这个术语还包括 volatile类型的变量，显示锁（Explicit Lock）以及原子变量。

* 如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误，有三种方式可以修复这个问题：
    > 1) 不在线程之间共享该状态变量
    > 2) 将状态变量修改为不可变的变量
    > 3) 在访问状态变量时使用同步

* 当设计线程安全类时，良好的面向对象技术、不可修改性，以及明确的不变性规范都能起到一定的帮助作用。 


##
## 2.1 什么是线程安全性

* 当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。
* 由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。

## 2.2 原子性

* 在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）。

### 2.2.1 竞态条件
* 当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。
* 最常见的竞态条件类型就是“先检查后执行”（CHeck-Then-Act）操作，即通过一个可能失效的观测结果来决定下一步的动作。

### 2.2.2 示例：延迟初始化中的竞态条件
* 使用“先检查后执行”的一种常见情况就是延迟初始化。
* 延迟初始化的目的就是讲对象的初始化操作推迟到实际使用时才进行，同时要确保只被初始化一次。

### 2.2.3 复合操作
* 复合操作：包含了一组必须以原子方式执行的操作以确保线程安全性。
* 在实际情况中，要尽可能地使用现有的线程安全对象来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换情况要更容易，从而也更容易维护和验证线程安全性。

## 2.3 加锁机制

* 要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

### 2.3.1 内置锁
* Java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。
* 同步代码块包括两个部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。
```
synchronized (locak) {
    //访问或修改由锁保护的共享对象
}
```
* 以关键字 synchronized 修饰的额方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是调用所在的对象。
* 每个Java对象都可以作为一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。线程在进入代码块之前会自动获得锁，并且在退出代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。
* Java内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。
* 并发环境中的原子性与事务应用程序中的原子性有着相同的含义————一组语句作为一个不可分割的单元被执行。

### 2.3.2 重入
* 当某个线程 请求一个由其他线程持有的锁时，发出请求的线程会被阻塞。然而，由于内置锁是可以重入的，因此如果某个线程视图获得一个已经由它自己持有的锁，那么这个请求就会成功。
* “重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。
* 重入的一种实现方法是：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取的计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时。计数器会相应的递减。当计数值为0时，这个锁将被释放。
* 重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。

## 2.4 用锁来保护状态  ==（不是太理解，需要加深理解）==

* 由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议实现对共享状态的独占访问。
* 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。
* 每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
* 一种常见的加锁约定是：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。许多线程安全类都使用了这种模式，例如 Vector 和其他的同步集合类。
* 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
* 不能不加区别的滥用 synchronized，这可能导致程序中出现过多的同步。虽然 synchronized 方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制，将每个方法都作为同步方法，并不足以确保复合操作都是原子的。此外，将每个方法都作为同步方法还可能导致活跃性问题（Liveness）或性能问题（Performance）。

## 2.5 活跃性与性能

* 不良并发（Poor Concurrency）应用程序：可同时调用的数量，不仅受到可用处理资源的限制，还受到应用程序本身结构的限制。
* 通过缩小同步代码块的作用范围，可以做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要将本应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。
* 要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（这个需求必须得到满足）、简单性和性能。

    > 通常，在简单性与性能之间存在着相互制约因素。当实现某个策略时，一定不要盲目为了性能而牺牲简单性（这可能会破坏安全性）。
    
* 当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。
    
    > 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。